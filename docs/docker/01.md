# 基本概念

Docker 包括三个重要的概念：**镜像**、**容器**、**仓库**，理解了这三个概念，就理解了 Docker 的整个生命周期。

## 镜像

操作系统分为 **内核** 和 **用户空间**。对于 Linux 而言，内核启动后，会挂载 **root 文件系统** 为其提供用户空间支持。而 **Docker 镜像**（`Image`），就相当于是一个 **root 文件系统**。

> [!TIP] 比如:
> 比如官方镜像 ubuntu:18.04 就包含了完整的一套 Ubuntu 18.04 最小系统的 root 文件系统。


**Docker 镜像** 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。

> [!TIP] 注意:
> 镜像**不包含**任何动态数据，其内容在构建之后也不会被改变。

为了避免镜像体积过于庞大，Docker 设计时，就充分利用 **Union FS** 的技术，将其设计为分层存储的架构。镜像并非是像一个 `ISO` 那样的打包文件，镜像只是一个虚拟的概念，其实际体现并非由一个文件组成，而是由一组文件系统组成，或者说，由多层文件系统联合组成。

## 容器

镜像（`Image`）和容器（`Container`）的关系，就像是面向对象程序设计中的 类 和 实例 一样，镜像是静态的定义，容器是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。

> [!TIP] 注意:
> 容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的 **命名空间**。因此容器可以拥有自己的 **root 文件系统**、自己的网络配置、自己的进程空间，甚至自己的用户 ID 空间。容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。这种特性使得容器封装的应用比直接在宿主运行更加安全。

镜像使用的是分层存储，容器也是如此。每一个容器运行时，是以镜像为基础层，在其上创建一个当前容器的存储层，可以称这个为容器运行时读写而准备的存储层为 **容器存储层**。

> [!TIP] 注意:
> 容器存储层的生存周期和容器一样，容器消亡时，容器存储层也随之消亡。因此，任何保存于容器存储层的信息都会随容器删除而丢失。需要保留数据时，应该使用 **数据卷（Volume）**、或者 **绑定宿主机目录**。

## 仓库

镜像构建完成后，如果需要在其它服务器上使用这个镜像，这时就需要一个集中的存储、分发镜像的服务，**Docker Registry** 就是这样的服务。

> [!TIP] 说明:
> 一个 **Docker Registry** 中可以包含多个 **仓库**（`Repository`）；每个仓库可以包含多个 **标签**（`Tag`）；每个标签对应一个镜像。


最常使用的 Registry 公开服务是官方的 [Docker Hub](https://hub.docker.com/)，也是默认的 Registry，并拥有大量的高质量的 **官方镜像**。

除了使用公开服务外，用户还可以在本地搭建私有 Docker Registry。Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。